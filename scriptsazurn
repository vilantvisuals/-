local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/vilantvisuals/vilantui2/refs/heads/main/!'))()

local Window = Library:CreateWindow({

    Title = 'Sazurn Hub | Da Hood | by grap3',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.6
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Player = Window:AddTab('Player'),
    Visuals = Window:AddTab('Visuals'),
}

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Aimbot')

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local cursorLocked = false
local targetHead = nil
local targetPlayer = nil
local predictionLevel = 0
local currentKeybind = Enum.KeyCode.C
local smoothness = 0

if _G.aimlock == nil then
    _G.aimlock = false
end

local function GetPredictedPosition(player)
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        local head = character:FindFirstChild("Head")
        if humanoid and head then
            local velocity = humanoid.RootPart.AssemblyLinearVelocity
            return head.Position + velocity * predictionLevel
        end
    end
    return nil
end

local function FindClosestPlayerHead()
    local closestPlayer = nil
    local closestDistance = math.huge
    local mousePosition = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local character = player.Character
            local humanoid = character:FindFirstChild("Humanoid")

            if humanoid and humanoid.Health > 0 then
                local head = character.Head
                local predictedHeadPosition = GetPredictedPosition(player) or head.Position
                local screenPoint = Camera:WorldToScreenPoint(predictedHeadPosition)
                local distance = (mousePosition - Vector2.new(screenPoint.X, screenPoint.Y)).Magnitude
                local playerDistance = (Camera.CFrame.Position - predictedHeadPosition).Magnitude

                local ray = Ray.new(Camera.CFrame.Position, predictedHeadPosition - Camera.CFrame.Position)
                local hitPart = Workspace:FindPartOnRay(ray, LocalPlayer.Character)

                if playerDistance <= 100 or (not hitPart or hitPart.Parent == character) then
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end

    if closestPlayer then
        return closestPlayer.Character.Head, closestPlayer
    end
    return nil, nil
end

local function LockCursorToHead()
    targetHead, targetPlayer = FindClosestPlayerHead()
    if targetHead then
        UserInputService.MouseIconEnabled = false
    end
end

local function UnlockCursor()
    UserInputService.MouseIconEnabled = true
    targetHead = nil
    targetPlayer = nil
end

RunService.Stepped:Connect(function()
    if cursorLocked and _G.aimlock and targetHead then
        local predictedHeadPosition = GetPredictedPosition(targetPlayer) or targetHead.Position
        local alpha = 1 - smoothness
        alpha = math.max(alpha, 0.01)
        Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, predictedHeadPosition), alpha)
    elseif not cursorLocked and _G.aimlock then
        local closestHead, closestPlayer = FindClosestPlayerHead()
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == currentKeybind then
        if _G.aimlock then
            cursorLocked = not cursorLocked
            if cursorLocked then
                LockCursorToHead()
            else
                UnlockCursor()
            end
        end
    end
end)

LeftGroupBox:AddToggle('Aimbot', {
    Text = 'Aimbot',
    Default = false,
    Tooltip = 'Locks your aim onto players heads',
    Callback = function(Value)
        _G.aimlock = Value
        cursorLocked = false
        print('[cb] Aimbot changed to:', Value)
    end
}):AddKeyPicker('KeyPicker', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Aimbot',
    ChangedCallback = function(New)
        print('[cb] Keybind changed!', New)
        currentKeybind = New
    end
})

LeftGroupBox:AddSlider('SmoothnessSlider', {
    Text = 'Smoothness',
    Default = smoothness,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        print('[cb] Smoothness changed!', Value)
        smoothness = Value
    end
})

LeftGroupBox:AddSlider('PredictionSlider', {
    Text = 'Prediction',
    Default = predictionLevel,
    Min = 0,
    Max = 1,
    Rounding = 1,
    Callback = function(Value)
        print('[cb] Prediction changed!', Value)
        predictionLevel = Value
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Kill Aura')

local range = 100
local killAuraEnabled = false

LeftGroupBox:AddToggle('MyToggle', {
    Text = 'Kill Aura',
    Default = false,
    Tooltip = 'Enables The Kill Aura Feature',
    Callback = function(Value)
        if Value then
            player = game:GetService("Players").LocalPlayer
            runService = game:GetService("RunService")
            workspace = game:GetService("Workspace")

            killAuraEnabled = true

            local lastDamagedPlayer = nil

            function isGunEquipped()
                local character = player.Character
                if character then
                    local tool = character:FindFirstChildWhichIsA("Tool")
                    return tool and tool:FindFirstChild("Handle") ~= nil
                end
                return false
            end

            function isTargetValid(targetCharacter)
                if targetCharacter then
                    local bodyEffects = targetCharacter:FindFirstChild("BodyEffects")
                    local KOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                    local Grabbed = targetCharacter:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                    return not KOd and not Grabbed
                end
                return false
            end

            function getNearestPlayer()
                local character = player.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                local nearestPlayer = nil
                local shortestDistance = range

                if rootPart then
                    for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
                        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and isTargetValid(plr.Character) then
                            local targetRootPart = plr.Character:FindFirstChild("HumanoidRootPart")
                            local distance = (targetRootPart.Position - rootPart.Position).Magnitude

                            if distance <= shortestDistance then
                                nearestPlayer = plr
                                shortestDistance = distance
                            end
                        end
                    end
                end
                return nearestPlayer
            end

            function shootNearestPlayer()
                if not killAuraEnabled or not isGunEquipped() then
                    return
                end

                local character = player.Character
                local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                local tool = character and character:FindFirstChildWhichIsA("Tool") or player.Backpack:FindFirstChildWhichIsA("Tool")
                local targetPlayer = getNearestPlayer()

                if tool and tool:FindFirstChild("Handle") and rootPart and targetPlayer and targetPlayer.Character then
                    local targetHead = targetPlayer.Character:FindFirstChild("Head")
                    if targetHead then
                        local direction = (targetHead.Position - rootPart.Position).unit
                        game:GetService("ReplicatedStorage"):WaitForChild("MainEvent"):FireServer("ShootGun", tool.Handle, rootPart.Position, targetHead.Position, targetHead, direction)
                    end
                end
            end

            runService.Heartbeat:Connect(function()
                if killAuraEnabled then
                    shootNearestPlayer()
                end
            end)
        else
            killAuraEnabled = false
        end
    end
})

LeftGroupBox:AddSlider('KillAuraRange', {
    Text = 'Bullets Range',
    Default = 100,
    Min = 10,
    Max = 500,
    Rounding = 0,
    Tooltip = 'Adjust the range of Kill Aura',
    Callback = function(value)
        range = value
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Hitbox Expander')

getgenv().sazurn = {
    hitbox_expander = {
        Enabled = false,
        ShowHitboxes = false,
        XSize = 1,
        YSize = 1,
        ZSize = 1,
        Color = Color3.fromRGB(5, 126, 255),
        Transparency = 0.3,
        Material = Enum.Material.ForceField,  -- Default material
    }
}

local LocalPlayer = Players.LocalPlayer
local TrackedPlayers = {}

local function UpdateHitbox(player, enable)
    if player == LocalPlayer then return end

    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local hrp = character.HumanoidRootPart
        if enable then
            hrp.Size = Vector3.new(getgenv().sazurn.hitbox_expander.XSize, getgenv().sazurn.hitbox_expander.YSize, getgenv().sazurn.hitbox_expander.ZSize)
            hrp.Transparency = getgenv().sazurn.hitbox_expander.ShowHitboxes and getgenv().sazurn.hitbox_expander.Transparency or 1
            hrp.Material = getgenv().sazurn.hitbox_expander.Material
            hrp.CanCollide = false
            hrp.Color = getgenv().sazurn.hitbox_expander.Color
        else
            hrp.Size = Vector3.new(2, 2, 1)
            hrp.Transparency = 1
            hrp.Material = Enum.Material.SmoothPlastic
            hrp.CanCollide = true
        end
    end
end

local function TrackPlayers()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and not TrackedPlayers[player] then
            TrackedPlayers[player] = player.CharacterAdded:Connect(function(character)
                if getgenv().sazurn.hitbox_expander.Enabled then
                    UpdateHitbox(player, true)
                end
                player.CharacterRemoving:Connect(function()
                    UpdateHitbox(player, false)
                end)
            end)
        end
    end
end

local function ApplyHitboxExpander()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            UpdateHitbox(player, getgenv().sazurn.hitbox_expander.Enabled)
        end
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        TrackPlayers()
    end
end)

TrackPlayers()

LeftGroupBox:AddToggle('ExpandHitboxToggle', {
    Text = 'Expand',
    Default = false,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.Enabled = Value
        ApplyHitboxExpander()
    end
}):AddKeyPicker('HitboxKeybind', {
    Default = '',
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.Enabled = not getgenv().sazurn.hitbox_expander.Enabled
        ApplyHitboxExpander()
    end
})

LeftGroupBox:AddToggle('ShowHitboxToggle', {
    Text = 'Show Hitboxes',
    Default = false,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.ShowHitboxes = Value
        ApplyHitboxExpander()
    end
}):AddKeyPicker('ShowHitboxKeybind', {
    Default = '',
    Mode = 'Toggle',
    Text = '',
    NoUI = false,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.ShowHitboxes = not getgenv().sazurn.hitbox_expander.ShowHitboxes
        ApplyHitboxExpander()
    end
})

LeftGroupBox:AddSlider('XSizeSlider', {
    Text = 'size-X',
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.XSize = Value
        ApplyHitboxExpander()
    end
})

LeftGroupBox:AddSlider('YSizeSlider', {
    Text = 'size-Y',
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.YSize = Value
        ApplyHitboxExpander()
    end
})

LeftGroupBox:AddSlider('ZSizeSlider', {
    Text = 'size-Z',
    Default = 1,
    Min = 1,
    Max = 30,
    Rounding = 1,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.ZSize = Value
        ApplyHitboxExpander()
    end
})

LeftGroupBox:AddSlider('TransparencySlider', {
    Text = 'Transparency',
    Default = 0.3,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.Transparency = Value
        ApplyHitboxExpander()
    end
})

LeftGroupBox:AddDropdown('MaterialDropdown', {
    Text = 'Material',
    Default = 'ForceField',
    Values = {
        'ForceField',
        'SmoothPlastic',
        'Glass',
        'Brick',
        'Wood',
        'Plastic',
        'Metal',
        'Slate',
        'DiamondPlate',
        'Neon'
    },
    Callback = function(Value)
        getgenv().sazurn.hitbox_expander.Material = Enum.Material[Value]
        ApplyHitboxExpander()
    end
})

LeftGroupBox = Tabs.Main:AddLeftGroupbox('Triggerbot')

local lp = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() and Players.LocalPlayer local mouse = lp:GetMouse()

local EnumKeyCode = Enum.KeyCode local EnumUserInputType = Enum.UserInputType

local Script = { Functions = {}, Table = { Start = { TriggerBot = { Keybind = "", Delay = 0.1, Blacklisted = {} } } }, Connections = {} }

Script.Functions.isDead = function(player) local character = player.Character if not character then return false end

local bodyEffects = character:FindFirstChild("BodyEffects")
if not bodyEffects then return false end

local ko = bodyEffects:FindFirstChild("K.O") or bodyEffects:FindFirstChild("KO")
return ko and ko.Value or false

end

Script.Functions.getTarget = function(instance) if not instance then return false end

for _, player in next, Players:GetPlayers() do
    if player.Character and instance:IsDescendantOf(player.Character) then
        if not Script.Functions.isDead(player) then
            return player
        end
    end
end

return false

end

Script.Functions.isToolBlacklisted = function(tool) for _, toolName in ipairs(Script.Table.Start.TriggerBot.Blacklisted) do if tool.Name == toolName then return true end end return false end

local JAIROUGH = false local hotkeyEnabled = false local highlightEnabled = false local lastHoveredPlayer = nil

Script.Functions.updateDelay = function(Value) Script.Table.Start.TriggerBot.Delay = Value end

Script.Functions.onKeyPress = function(input, gameProcessed) if gameProcessed then return end

if hotkeyEnabled and input.UserInputType == EnumUserInputType.Keyboard and input.KeyCode == Enum.KeyCode[Script.Table.Start.TriggerBot.Keybind] then
    JAIROUGH = not JAIROUGH
end

end

Script.Functions.updateKeybind = function(NewKey) Script.Table.Start.TriggerBot.Keybind = NewKey.Name end

UserInputService.InputBegan:Connect(Script.Functions.onKeyPress)

Script.Functions.highlightTarget = function(targetPlayer) if highlightEnabled and JAIROUGH then if lastHoveredPlayer and lastHoveredPlayer ~= targetPlayer then local oldCharacter = lastHoveredPlayer.Character if oldCharacter then local highlight = oldCharacter:FindFirstChild("ChamHighlight") if highlight then highlight:Destroy() end end end

if targetPlayer and targetPlayer.Character then
        local character = targetPlayer.Character
        if not character:FindFirstChild("ChamHighlight") then
            local highlight = Instance.new("Highlight")
            highlight.Name = "ChamHighlight"
            highlight.Parent = character
            highlight.Adornee = character
            highlight.FillColor = Color3.fromRGB(255, 0, 0)  
            highlight.FillTransparency = 0.5
            highlight.OutlineTransparency = 1
        end
        lastHoveredPlayer = targetPlayer  
    end
else
    if lastHoveredPlayer and lastHoveredPlayer.Character then
        local highlight = lastHoveredPlayer.Character:FindFirstChild("ChamHighlight")
        if highlight then
            highlight:Destroy()
        end
    end
end

end

Script.Functions.triggerBot = function() local con con = RunService.Heartbeat:Connect(function() if JAIROUGH then local target = mouse.Target local targetPlayer = Script.Functions.getTarget(target) Script.Functions.highlightTarget(targetPlayer)

if targetPlayer and lp.Character then
            local tool = lp.Character:FindFirstChildWhichIsA('Tool')
            if tool and not Script.Functions.isToolBlacklisted(tool) then
                task.wait(Script.Table.Start.TriggerBot.Delay)
                tool:Activate()
            end
        end
    end
end)

Script.Connections.triggerBot = con

end

Script.Functions.triggerBot()

getgenv().disable = function() getgenv().disable = nil if Script.Connections.triggerBot then Script.Connections.triggerBot:Disconnect() end end

LeftGroupBox:AddToggle('EnableTriggerBot', { Text = 'Triggerbot', Default = false, Tooltip = 'Enable or Disable the hotkey for TriggerBot', Callback = function(Value) hotkeyEnabled = Value

if not hotkeyEnabled then
        JAIROUGH = false
    end
end

}):AddKeyPicker('KeyPicker', { Default = Script.Table.Start.TriggerBot.Keybind, SyncToggleState = false, Mode = 'Toggle', Text = '', NoUI = false, ChangedCallback = function(New) Script.Functions.updateKeybind(New) end })

LeftGroupBox:AddToggle('HighlightToggle', { Text = 'Highlight', Default = false, Tooltip = 'Player highlight when triggerbot is active', Callback = function(Value) highlightEnabled = Value end })

LeftGroupBox:AddSlider('DelaySlider', { Text = 'Delay', Default = Script.Table.Start.TriggerBot.Delay, Min = 0, Max = 1, Rounding = 3, Compact = false, Callback = function(Value) Script.Functions.updateDelay(Value) end })

RunService.Heartbeat:Connect(function() if highlightEnabled and JAIROUGH then local target = mouse.Target local targetPlayer = Script.Functions.getTarget(target)

if targetPlayer then
        Script.Functions.highlightTarget(targetPlayer)
    elseif lastHoveredPlayer then
        Script.Functions.highlightTarget(nil)
    end
elseif lastHoveredPlayer then
    Script.Functions.highlightTarget(nil)
end

end)

RightGroupbox = Tabs.Main:AddRightGroupbox('Shoot Gun')

getgenv().TracerEnabled = true
getgenv().AutoShootEnabled = true
getgenv().shootCooldown = 0.1
getgenv().ScriptEnabled = false
getgenv().LockKey = Enum.KeyCode.T

local MainEvent = ReplicatedStorage:FindFirstChild("MainEvent")
local selectedPlayer = nil
local lockedPlayer = nil

local tracer = Drawing.new("Line")
tracer.Thickness = 1.2
tracer.Visible = false
tracer.Color = Color3.fromRGB(128, 0, 128)

if not MainEvent then
    return
end

local function isKnocked(player)
    if player and player.Character then
        local KO = player.Character:FindFirstChild("BodyEffects") and player.Character.BodyEffects:FindFirstChild("K.O")
        return KO and KO.Value == true
    end
    return false
end

local function getClosestPlayerToMouse()
    local closestPlayer = nil
    local shortestDistance = math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and not isKnocked(player) then
            local head = player.Character.Head
            local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

            if onScreen then
                local distance = (Vector2.new(headScreenPos.X, headScreenPos.Y) - mousePos).Magnitude
                if distance < shortestDistance then
                    closestPlayer = player
                    shortestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

local function updateTracer()
    if getgenv().TracerEnabled and getgenv().ScriptEnabled then
        local targetPlayer = lockedPlayer or getClosestPlayerToMouse()

        if targetPlayer then
            local head = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head")
            if head then
                local headScreenPos, onScreen = Camera:WorldToViewportPoint(head.Position)

                if onScreen then
                    selectedPlayer = targetPlayer
                    tracer.Visible = true
                    tracer.To = Vector2.new(headScreenPos.X, headScreenPos.Y)
                    tracer.From = UserInputService:GetMouseLocation()
                end
            end
        else
            tracer.Visible = false
        end
    end
end

local function shoot()
    if lockedPlayer and lockedPlayer.Character and not isKnocked(lockedPlayer) and getgenv().ScriptEnabled then
        local targetHead = lockedPlayer.Character:FindFirstChild("Head")
        local Tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")

        if Tool and Tool:FindFirstChild("Handle") and targetHead then
            MainEvent:FireServer(
                "ShootGun",
                Tool.Handle,
                Tool.Handle.Position,
                targetHead.Position,
                targetHead,
                Vector3.new(0, 0, 0)
            )
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == getgenv().LockKey and not gameProcessed then
        if getgenv().ScriptEnabled then
            if lockedPlayer then
                lockedPlayer = nil
            else
                lockedPlayer = getClosestPlayerToMouse()
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if getgenv().ScriptEnabled then
        updateTracer()

        if lockedPlayer then
            shoot()
        end
    else
        tracer.Visible = false
    end
end)

RightGroupbox:AddToggle('ScriptToggle', {
    Text = 'Shoot Gun',
    Default = false,

    Callback = function(Value)
        if Value then
            getgenv().ScriptEnabled = true
        else
            getgenv().ScriptEnabled = false
            tracer.Visible = false
        end
    end
}):AddKeyPicker('KeyPicker', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Shoot Gun Keybind',
    NoUI = false,

    Callback = function(Value)
    end,

    ChangedCallback = function(New)
        getgenv().LockKey = New
    end
})

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local RightGroupbox = Tabs.Main:AddRightGroupbox('Check')

local utility = {}

getgenv().config = {
    enable = false,
    hold_fire = false,
    delay = 0.01
}

getgenv().is_firing = false

function utility.get_gun()
    for _, tool in ipairs(character:GetChildren()) do
        if tool:IsA("Tool") and tool:FindFirstChild("Ammo") then
            return tool
        end
    end
end

function utility.rapid(tool)
    tool:Activate()
end

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local gun = utility.get_gun()
        if config.enable and gun and not is_firing then
            is_firing = true
            task.spawn(function()
                while is_firing and config.enable and gun do
                    utility.rapid(gun)
                    task.wait(config.delay)
                end
            end)
        elseif config.hold_fire and gun and not is_firing then
            is_firing = true
            task.spawn(function()
                while is_firing and config.hold_fire and gun do
                    utility.rapid(gun)
                    task.wait(config.delay)
                end
            end)
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        is_firing = false
    end
end)

RightGroupbox:AddToggle('RapidFireToggle', {
    Text = 'Rapid Fire',
    Default = false,
    Tooltip = 'Enable or disable rapid fire (auto for auto guns)',
    Callback = function(enabled)
        config.enable = enabled
        if not enabled then
            is_firing = false
        end
    end
})

RightGroupbox:AddToggle('HoldFireToggle', {
    Text = 'Hold Fire',
    Default = false,
    Tooltip = 'Hold to auto-shoot for guns like revolver',
    Callback = function(enabled)
        config.hold_fire = enabled
        if not enabled then
            is_firing = false
        end
    end
})

function Recalculate(Character)
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        return Vector3.zero
    end

    local root = Character.HumanoidRootPart
    local initial = root.Position
    local startTime = tick()

    task.wait(0.03)

    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        return Vector3.zero
    end

    local final = root.Position
    local endTime = tick()
    local deltaTime = endTime - startTime

    if deltaTime <= 0 then return Vector3.zero end

    return (final - initial) / deltaTime
end

RightGroupbox:AddToggle('ResolverToggle', {
    Text = 'Resolver',
    Default = false,
    Tooltip = 'Enable or disable the velocity resolver',
    Callback = function(Value)
        getgenv().config.enable = Value
    end
})

RunService.Heartbeat:Connect(function()
    if getgenv().config.enable then
        local targetCharacter = game.Players:FindFirstChild("TargetPlayerName")
        if targetCharacter then
            local velocity = Recalculate(targetCharacter)
        end
    end
end)

local tool
local ammoValue

local function handleAutoReload()
    tool = player.Character and player.Character:FindFirstChildWhichIsA("Tool")
    if tool and tool:FindFirstChild("Ammo") then
        ammoValue = tool.Ammo.Value
        if ammoValue <= 0 then
            MainEvent:FireServer("Reload", tool)
        end
    end
end

RightGroupbox:AddToggle('AutoReloadToggle', {
    Text = 'Auto Reload',
    Default = false,
    Tooltip = 'Reloads Automatically when 0 ammo',
    Callback = function(Value)
        _G.AutoReload = Value
    end
})

local autoReloadConnection
autoReloadConnection = RunService.Heartbeat:Connect(function()
    if _G.AutoReload then
        handleAutoReload()
    end
end)

local function cleanup()
    if autoReloadConnection then
        autoReloadConnection:Disconnect()
        autoReloadConnection = nil
    end
end

player.CharacterAdded:Connect(function()
end)

RightGroupbox = Tabs.Main:AddRightGroupbox('Silent Aim')

local TargetAim = {
    Enabled = false,
    Keybind = Enum.KeyCode.Unknown,
    LockedTarget = nil,
    HitPart = "Head",
    ExcludeKOPlayers = false
}

local HighlightEnabled = false
local NotifyEnabled = false
local highlightColor = Color3.fromRGB(255, 255, 255)
local ESPObjects = {}

RightGroupbox:AddToggle('Enable Target Aim', {
    Text = 'Enable',
    Default = TargetAim.Enabled,
    Tooltip = 'Toggle Target Aim on/off',
    Callback = function(Value)
        TargetAim.Enabled = Value
    end
}):AddKeyPicker('KeyPicker', {
    Default = '',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Target Aim Key',
    NoUI = false,
    ChangedCallback = function(New)
        TargetAim.Keybind = New
    end
})

RightGroupbox:AddToggle('Highlight Toggle', {
    Text = 'Highlight',
    Default = false,
    Tooltip = 'Toggle highlight for locked target',
    Callback = function(Value)
        HighlightEnabled = Value
        if TargetAim.LockedTarget then
            if HighlightEnabled then
                CreateCham(TargetAim.LockedTarget.Parent)
            else
                DestroyCham(TargetAim.LockedTarget.Parent)
            end
        end
    end
}):AddColorPicker('Highlight Color', {
    Text = 'Highlight Color',
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(Value)
        highlightColor = Value
        if TargetAim.LockedTarget then
            local highlight = TargetAim.LockedTarget.Parent:FindFirstChild("ChamHighlight")
            if highlight then
                highlight.FillColor = highlightColor
            end
        end
    end
})

RightGroupbox:AddToggle('Notify Toggle', {
    Text = 'Notify',
    Default = false,
    Tooltip = 'Notify when you lock target',
    Callback = function(Value)
        NotifyEnabled = Value
    end
})

RightGroupbox:AddToggle('Exclude KO Players', {
    Text = 'Knock check',
    Default = TargetAim.ExcludeKOPlayers,
    Tooltip = 'Prevent from locking onto knocked players',
    Callback = function(Value)
        TargetAim.ExcludeKOPlayers = Value
    end
})

local function GetClosestTarget()
    local ClosestPart, ClosestPlayer
    local MousePosition = UserInputService:GetMouseLocation()
    local ClosestDistance = math.huge

    for _, Player in next, Players:GetPlayers() do
        if Player ~= LocalPlayer and Player.Character then
            local Character = Player.Character
            local HitPart = Character:FindFirstChild(TargetAim.HitPart)
            local Humanoid = Character:FindFirstChild("Humanoid")
            local BodyEffects = Character:FindFirstChild("BodyEffects")
            local IsKO = BodyEffects and BodyEffects:FindFirstChild("K.O") and BodyEffects["K.O"].Value

            if HitPart and Humanoid and Humanoid.Health > 0 and (not TargetAim.ExcludeKOPlayers or not IsKO) then
                local ScreenPosition, Visible = Camera:WorldToScreenPoint(HitPart.Position)
                if Visible then
                    local Distance = (Vector2.new(ScreenPosition.X, ScreenPosition.Y) - MousePosition).Magnitude
                    if Distance < ClosestDistance then
                        ClosestDistance = Distance
                        ClosestPart, ClosestPlayer = HitPart, Player
                    end
                end
            end
        end
    end

    return ClosestPart, ClosestPlayer
end

local function CreateCham(character)
    if ESPObjects[character] then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ChamHighlight"
    highlight.Parent = character
    highlight.Adornee = character
    highlight.FillColor = highlightColor
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 1

    ESPObjects[character] = { Highlight = highlight }

    character:WaitForChild("HumanoidRootPart").AncestryChanged:Connect(function()
        highlight:Destroy()
        ESPObjects[character] = nil
    end)
end

local function DestroyCham(character)
    if ESPObjects[character] then
        ESPObjects[character].Highlight:Destroy()
        ESPObjects[character] = nil
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        task.wait(0.5)
        if TargetAim.Enabled and HighlightEnabled and TargetAim.LockedTarget and TargetAim.LockedTarget.Parent == character then
            CreateCham(character)
        end
    end)
end)

Players.PlayerRemoving:Connect(DestroyCham)

RunService.Heartbeat:Connect(function()
    if TargetAim.Enabled and HighlightEnabled then
        if TargetAim.LockedTarget and TargetAim.LockedTarget.Parent then
            local targetCharacter = TargetAim.LockedTarget.Parent
            if not ESPObjects[targetCharacter] then
                CreateCham(targetCharacter)
            end
        end
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character then
                DestroyCham(player.Character)
            end
        end
    end
end)

UserInputService.InputBegan:Connect(function(Input, Processed)
    if not Processed and Input.KeyCode == TargetAim.Keybind then
        if TargetAim.Enabled then
            if TargetAim.LockedTarget then
                if HighlightEnabled then
                    DestroyCham(TargetAim.LockedTarget.Parent)
                end
                if NotifyEnabled then
                    Library:Notify("Target Released", 2)
                end
                TargetAim.LockedTarget = nil
            else
                local TargetPart, TargetPlayer = GetClosestTarget()
                TargetAim.LockedTarget = TargetPart
                if TargetPlayer then
                    if HighlightEnabled then
                        CreateCham(TargetPlayer.Character)
                    end
                    if NotifyEnabled then
                        Library:Notify("Locked onto " .. TargetPlayer.Name, 3)
                    end
                end
            end
        end
    end
end)

local grm, index
local success, errorMsg = pcall(function()
    grm = getrawmetatable(game)
    index = grm.__index
end)

if not success then
    warn("silent aim not supported on your executor: " .. errorMsg)
else
    setreadonly(grm, false)
    grm.__index = function(self, Index)
        if not checkcaller() and self == Mouse and TargetAim.Enabled and TargetAim.LockedTarget then
            if Index == "Hit" or Index == "Target" then
                return CFrame.new(TargetAim.LockedTarget.Position)
            end
        end
        return index(self, Index)
    end
end

local uhhh = Tabs.Player:AddLeftGroupbox('Movement')  

uhhh:AddToggle('WalkSpeedToggle', {
    Text = 'Enable WalkSpeed',
    Default = false,
    Callback = function(state)
        getgenv().walkSpeedEnabled = state
        if not state then getgenv().walkSpeedKeybindActive = false end
    end,
}):AddKeyPicker('WalkSpeedKeybind', {
    Default = '',
    Text = 'Speed Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        if getgenv().walkSpeedEnabled then getgenv().walkSpeedKeybindActive = state end
    end,
})  

uhhh:AddSlider('WalkSpeedSlider', {
    Text = 'Speed',
    Default = 16,
    Min = 16,
    Max = 500,
    Rounding = 0,
    Callback = function(value)
        getgenv().walkSpeed = value
    end,
})  

game:GetService('RunService').RenderStepped:Connect(function()
    local player = game.Players.LocalPlayer
    local character = player.Character
    local humanoid = character and character:FindFirstChild('Humanoid') 

    if not humanoid then return end

    local userInputService = game:GetService("UserInputService")
    local isSprinting = userInputService:IsKeyDown(Enum.KeyCode.LeftShift) or userInputService:IsKeyDown(Enum.KeyCode.RightShift) 

    if getgenv().walkSpeedEnabled and getgenv().walkSpeedKeybindActive then
        humanoid.WalkSpeed = getgenv().walkSpeed
    elseif isSprinting then
        humanoid.WalkSpeed = 26
    else
        humanoid.WalkSpeed = 16
    end
end)

getgenv().cframeSpeedEnabled = false
getgenv().cframeSpeedKeybindActive = false
getgenv().cframeSpeedAmount = 150
getgenv().cframeSpeedKeybind = Enum.KeyCode.V  

uhhh:AddToggle('CFrameSpeedToggle', {
    Text = 'CFrame Speed',
    Default = false,
    Tooltip = 'Toggles speed using CFrame',
    Callback = function(state)
        getgenv().cframeSpeedEnabled = state
        if not state then
            getgenv().cframeSpeedKeybindActive = false
        end
    end,
}):AddKeyPicker('CFrameSpeedKeybind', {
    Default = '',
    Text = 'Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        getgenv().cframeSpeedKeybindActive = state
    end,
})

uhhh:AddSlider('CFrameSpeedSlider', {
    Text = 'Speed',
    Default = 150,
    Min = 16,
    Max = 1000,
    Rounding = 0,
    Callback = function(value)
        getgenv().cframeSpeedAmount = value
    end
})

local function hasCharacter(player)
    local character = player and player.Character
    return character and character:FindFirstChild("HumanoidRootPart", true) and character:FindFirstChild("Humanoid", true)
end

local function updateCframeSpeed(deltaTime)
    if getgenv().cframeSpeedEnabled and getgenv().cframeSpeedKeybindActive and hasCharacter(game.Players.LocalPlayer) then
        local character = game.Players.LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local humanoid = character:FindFirstChild("Humanoid", true)
        local moveDirection = humanoid and humanoid.MoveDirection 

        if hrp and moveDirection then
            local movement = moveDirection.Unit * getgenv().cframeSpeedAmount * deltaTime
            if movement.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + movement
            end
        end
    end
end

game:GetService("RunService").Heartbeat:Connect(updateCframeSpeed)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == getgenv().cframeSpeedKeybind then
        if getgenv().cframeSpeedToggleAllowed then
            getgenv().cframeSpeedKeybindActive = not getgenv().cframeSpeedKeybindActive
        end
    end
end)

getgenv().rageCFrameFlyEnabled = false
getgenv().rageCFrameFlyKeybindActive = false
getgenv().rageCFrameFlyAmount = 250
getgenv().rageCFrameFlyKeybind = Enum.KeyCode.B  

uhhh:AddToggle('CframeFlightToggle', {
    Text = 'Cframe Flight',
    Default = false,
    Tooltip = 'Toggles flight using CFrame',
    Callback = function(state)
        getgenv().rageCFrameFlyEnabled = state
        if not state then
            getgenv().rageCFrameFlyKeybindActive = false
        end
    end
}):AddKeyPicker('CframeFlyKeybind', {
    Default = '',
    Text = 'Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if game:GetService("UserInputService"):GetFocusedTextBox() then return end
        getgenv().rageCFrameFlyKeybindActive = state
    end,
})

uhhh:AddSlider('CframeFlightSpeed', {
    Text = 'Speed',
    Default = 250,
    Min = 16,
    Max = 2000,
    Rounding = 0,
    Callback = function(value)
        getgenv().rageCFrameFlyAmount = value
    end
})

local function updateFly(deltaTime)
    if getgenv().rageCFrameFlyEnabled and getgenv().rageCFrameFlyKeybindActive and hasCharacter(game.Players.LocalPlayer) then
        local character = game.Players.LocalPlayer.Character
        local hrp = character:FindFirstChild("HumanoidRootPart", true)
        local moveDirection = character:FindFirstChild("Humanoid", true).MoveDirection 

        local verticalSpeed = (UserInputService:IsKeyDown(Enum.KeyCode.Space) and 1 or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and -1 or 0)
        local verticalMovement = Vector3.new(0, verticalSpeed, 0) 

        local movement = (moveDirection + verticalMovement).Unit * getgenv().rageCFrameFlyAmount * deltaTime 

        if movement.Magnitude > 0 then
            hrp.CFrame = hrp.CFrame + movement
        end

        hrp.Velocity = Vector3.zero
    end
end

game:GetService("RunService").Heartbeat:Connect(updateFly)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == getgenv().rageCFrameFlyKeybind then
        if getgenv().rageCFrameFlyToggleAllowed then
            getgenv().rageCFrameFlyKeybindActive = not getgenv().rageCFrameFlyKeybindActive
        end
    end
end)

local function toggleNoJumpCooldown(enabled)
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")

    local function updateJumpSettings(humanoid, state)
        humanoid.UseJumpPower = not state
        print("Jump cooldown " .. (state and "disabled!" or "enabled!"))
    end

    updateJumpSettings(humanoid, enabled)

    player.CharacterAdded:Connect(function(newCharacter)
        local newHumanoid = newCharacter:WaitForChild("Humanoid")
        updateJumpSettings(newHumanoid, enabled)
    end)
end

uhhh:AddToggle('NoJumpCooldownToggle', {
    Text = 'Infinite Jump',
    Default = false,
    Tooltip = 'Toggles the jump cooldown on or off',
    Callback = function(value)
        _G.noJumpCooldownEnabled = value
        toggleNoJumpCooldown(value)
        print('[cb] NoJumpCooldownToggle changed to:', value)
    end
})

local stutz = Tabs.Player:AddLeftGroupbox('Character')

local antifling = nil
local lastChecked = 0
local checkInterval = 1

stutz:AddToggle("AntiflingToggle", {
    Text = "anti-fling",
    Default = false,
    Callback = function(state)
        if state then
            antifling = game:GetService("RunService").Stepped:Connect(function(_, time)
                if time - lastChecked >= checkInterval then
                    lastChecked = time
                    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
                        if player ~= game.Players.LocalPlayer and player.Character then
                            for _, v in pairs(player.Character:GetDescendants()) do
                                if v:IsA("BasePart") then
                                    v.CanCollide = false
                                end
                            end
                        end
                    end
                end
            end)
        else
            if antifling then
                antifling:Disconnect()
                antifling = nil
            end
        end
    end
})

local CollectionService = game:GetService("CollectionService")
local cachedSeats = {}

local function processSeat(seat, state)
    if seat:IsA("Seat") and not cachedSeats[seat] then
        cachedSeats[seat] = seat
    end
    if cachedSeats[seat] then
        seat.Disabled = state
        if state then
            CollectionService:AddTag(seat, "Seat")
        else
            CollectionService:RemoveTag(seat, "Seat")
        end
    end
end

local function initializeSeats()
    for _, object in ipairs(workspace:GetDescendants()) do
        if object:IsA("Seat") then
            cachedSeats[object] = object
        end
    end
end

local function monitorNewSeats()
    workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Seat") then
            processSeat(descendant, CollectionService:HasTag(descendant, "Seat"))
        end
    end)
end

stutz:AddToggle('NoSeatsToggle', {
    Text = 'No-Seats',
    Default = false,
    Callback = function(value)
        for seat, _ in pairs(cachedSeats) do
            if seat and seat:IsA("Seat") then
                seat.Disabled = value
                if value then
                    CollectionService:AddTag(seat, "Seat")
                else
                    CollectionService:RemoveTag(seat, "Seat")
                end
            end
        end
    end
})

stutz:AddToggle('AutoDropCashToggle', {
    Text = 'Auto Drop Cash',
    Default = false,
    Callback = function(Value)
        local Player = game:GetService("Players").LocalPlayer
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local RunService = game:GetService("RunService")
        local MainScreenGui = Player.PlayerGui.MainScreenGui
        local MoneyText = MainScreenGui.MoneyText

        getgenv().moneyDropEnabled = getgenv().moneyDropEnabled or false

        local function getMoneyAmount()
            local moneyText = MoneyText.Text:match("%$(%d[%,%d]*)")
            if moneyText then
                local cleanedMoneyString = moneyText:gsub(",", "")
                local amount = tonumber(cleanedMoneyString)
                return amount or 0
            else
                return 0
            end
        end

        local function dropMoney(amountToDrop)
            if amountToDrop > 0 then
                ReplicatedStorage.MainEvent:FireServer("DropMoney", tostring(amountToDrop))
            end
        end

        local function toggleMoneyDrop()
            getgenv().moneyDropEnabled = not getgenv().moneyDropEnabled
        end

        RunService.Heartbeat:Connect(function()
            if getgenv().moneyDropEnabled then
                local money = getMoneyAmount()
                dropMoney(money < 15000 and money or 15000)
            end
        end)

        toggleMoneyDrop()
    end
})

stutz:AddToggle('AutoReloadToggle', {
    Text = 'Auto-Reload',
    Default = false,
    Callback = function(Value)
        _G.AutoReload = Value
    end
})

stutz:AddToggle('SilentReloadToggle', {
    Text = 'Silent-Reload',
    Default = false,
    Callback = function(Value)
        setupSilentReload(Value)
        LocalPlayer.CharacterAdded:Connect(function()
            setupSilentReload(Value)
        end)
    end
})

local antiVoidEnabled = false
stutz:AddToggle('AntiVoidToggle', {
    Text = 'Anti-Void',
    Default = false,
    Callback = function(Value)
        antiVoidEnabled = Value
    end
})

local function antiVoidCheck()
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    if antiVoidEnabled and rootPart and rootPart.Position.Y <= -150 then
        rootPart.CFrame = rootPart.CFrame + Vector3.new(0, 500, 0)
    end
end

RunService.Heartbeat:Connect(antiVoidCheck)

RunService.Heartbeat:Connect(function()
    if _G.AutoReload then
        handleAutoReload()
    end
end)

local RunService = game:GetService("RunService")
local player = game.Players.LocalPlayer
local debris = game:GetService("Debris")

local antiStompEnabled = false

local HumanoidStateType = Enum.HumanoidStateType
local KOD = "K.O"
local GRABBING_CONSTRAINT = "GRABBING_CONSTRAINT"

stutz:AddToggle('MyToggle', {
    Text = 'Anti Stomp',
    Default = false,
    Callback = function(Value)
        antiStompEnabled = Value
    end
})

RunService.Heartbeat:Connect(function()
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    if character and humanoid then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        local KOd = bodyEffects and bodyEffects[KOD] and bodyEffects[KOD].Value
        local Grabbed = character:FindFirstChild(GRABBING_CONSTRAINT) ~= nil

        if antiStompEnabled and (KOd or Grabbed) then
            humanoid.PlatformStand = true
            humanoid.WalkSpeed = 0
            humanoid.JumpHeight = 0
            humanoid.Health = 0

            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end

            humanoid:SetStateEnabled(HumanoidStateType.Physics, false)
            humanoid:SetStateEnabled(HumanoidStateType.Seated, false)
            humanoid:SetStateEnabled(HumanoidStateType.Climbing, false)
            humanoid:SetStateEnabled(HumanoidStateType.Freefall, false)
            humanoid:SetStateEnabled(HumanoidStateType.Ragdoll, false)

            humanoid.MaxHealth = humanoid.Health

            if bodyEffects then
                bodyEffects:ClearAllChildren()
            end

            local collisionParts = character:GetChildren()
            for _, part in pairs(collisionParts) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end

            player:LoadCharacter()
        end
    end
end)

local animationBaseUrl = "http://www.roblox.com/asset/?id="

local animations = {
    R15 = {
        idle = animationBaseUrl .. "2510196951",
        walk = animationBaseUrl .. "2510202577",
        run = animationBaseUrl .. "2510198475",
        jump = animationBaseUrl .. "2510197830",
        climb = animationBaseUrl .. "2510192778",
        fall = animationBaseUrl .. "2510195892",
    },
    Custom = {
        idle = animationBaseUrl .. "782841498",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        jump = animationBaseUrl .. "1083218792",
        climb = animationBaseUrl .. "1083439238",
        fall = animationBaseUrl .. "707829716",
    },
     Levitation = {
        idle = animationBaseUrl .. "616006778",
        jump = animationBaseUrl .. "616008936",
        fall = animationBaseUrl .. "616005863",
        walk = animationBaseUrl .. "616013216",
        run = animationBaseUrl .. "616010382",
        climb = animationBaseUrl .. "616003713",
    },
    Mage = {
        idle = animationBaseUrl .. "707742142",
        jump = animationBaseUrl .. "707853694",
        fall = animationBaseUrl .. "707829716",
        walk = animationBaseUrl .. "707897309",
        run = animationBaseUrl .. "707861613",
        climb = animationBaseUrl .. "707826056",
    },
    Ninja = {
        idle = animationBaseUrl .. "656117400",
        jump = animationBaseUrl .. "656117878",
        fall = animationBaseUrl .. "656115606",
        walk = animationBaseUrl .. "656121766",
        run = animationBaseUrl .. "656118852",
        climb = animationBaseUrl .. "656114359",
    },
    Stylish = {
        idle = animationBaseUrl .. "616136790",
        jump = animationBaseUrl .. "616139451",
        fall = animationBaseUrl .. "616134815",
        walk = animationBaseUrl .. "616146177",
        run = animationBaseUrl .. "616140816",
        climb = animationBaseUrl .. "616133594",
    },
    Superhero = {
        idle = animationBaseUrl .. "616111295",
        jump = animationBaseUrl .. "616115533",
        fall = animationBaseUrl .. "616108001",
        walk = animationBaseUrl .. "616122287",
        run = animationBaseUrl .. "616117076",
        climb = animationBaseUrl .. "616104706",
    },
    Toy = {
        idle = animationBaseUrl .. "782841498",
        jump = animationBaseUrl .. "782847020",
        fall = animationBaseUrl .. "782846423",
        walk = animationBaseUrl .. "782843345",
        run = animationBaseUrl .. "782842708",
        climb = animationBaseUrl .. "782843869",
    },
    Vampire = {
        idle = animationBaseUrl .. "1083445855",
        jump = animationBaseUrl .. "1083455352",
        fall = animationBaseUrl .. "1083443587",
        walk = animationBaseUrl .. "1083473930",
        run = animationBaseUrl .. "1083462077",
        climb = animationBaseUrl .. "1083439238",
    },
    Werewolf = {
        idle = animationBaseUrl .. "1083195517",
        jump = animationBaseUrl .. "1083218792",
        fall = animationBaseUrl .. "1083189019",
        walk = animationBaseUrl .. "1083178339",
        run = animationBaseUrl .. "1083216690",
        climb = animationBaseUrl .. "1083182000",
    },
    Zombie = {
        idle = animationBaseUrl .. "616158929",
        jump = animationBaseUrl .. "616161997",
        fall = animationBaseUrl .. "616157476",
        walk = animationBaseUrl .. "616168032",
        run = animationBaseUrl .. "616163682",
        climb = animationBaseUrl .. "616156119",
    },
}

local function applyAnimations(animate, preset)
    if animate and preset then
        if animate.idle and animate.idle:FindFirstChild("Animation1") then
            animate.idle.Animation1.AnimationId = preset.idle
        else
            warn("Idle animation or Animation1 not found")
        end
        
        if animate.walk and animate.walk:FindFirstChild("WalkAnim") then
            animate.walk.WalkAnim.AnimationId = preset.walk
        else
            warn("Walk animation or WalkAnim not found")
        end

        if animate.run and animate.run:FindFirstChild("RunAnim") then
            animate.run.RunAnim.AnimationId = preset.run
        else
            warn("Run animation or RunAnim not found")
        end

        if animate.jump and animate.jump:FindFirstChild("JumpAnim") then
            animate.jump.JumpAnim.AnimationId = preset.jump
        else
            warn("Jump animation or JumpAnim not found")
        end

        if animate.climb and animate.climb:FindFirstChild("ClimbAnim") then
            animate.climb.ClimbAnim.AnimationId = preset.climb
        else
            warn("Climb animation or ClimbAnim not found")
        end

        if animate.fall and animate.fall:FindFirstChild("FallAnim") then
            animate.fall.FallAnim.AnimationId = preset.fall
        else
            warn("Fall animation or FallAnim not found")
        end
    end
end

local function applySelectedAnimations(character)
    local animate = character:FindFirstChild("Animate")
    if animate then
        local selectedPreset = animations[currentAnimationPreset]
        applyAnimations(animate, selectedPreset)
    end
end

local LeftGroupBox = Tabs.Player:AddLeftGroupbox('Player Animations')

LeftGroupBox:AddDropdown('AnimationSelector', {
    Values = {'R15', 'Custom', 'Levitation', 'Mage', 'Ninja', 'Stylish', 'Superhero', 'Toy', 'Vampire', 'Werewolf', 'Zombie',},
    Default = 1,
    Multi = false,

    Text = 'Animation',
    Tooltip = 'MUST RESET!!!',

    Callback = function(Value)
        currentAnimationPreset = Value
    end
})

local animationLoaded = false
local player = Players.LocalPlayer

if not player then
    warn("[Animation Error]: LocalPlayer not found!")
    return
end

local function applyAnimations()
    local character = player.Character
    if not character or not character.Parent then return end
    if animationLoaded then return end

    local animate = character:FindFirstChild("Animate")
    if not animate then 
        warn("[Animation Error]: Animate script missing!")
        return 
    end

    local success, err = pcall(function()
        applySelectedAnimations(character)
    end)

    if success then
        animationLoaded = true
    elseif not _G.AnimationErrorLogged then
        warn("[Animation Error]: " .. err)
        _G.AnimationErrorLogged = true
    end
end

local function onCharacterAdded(character)
    animationLoaded = false
    repeat task.wait() until character:FindFirstChild("HumanoidRootPart")
    applyAnimations()
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
    task.spawn(function()
        onCharacterAdded(player.Character)
    end)
end

local function onCharacterAdded(character)
    animationLoaded = false
    repeat task.wait() until character:FindFirstChild("Humanoid") and character:FindFirstChild("HumanoidRootPart")
    applyAnimations()
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart") then
    applyAnimations()
else
    task.spawn(function()
        repeat task.wait() until player.Character and player.Character:FindFirstChild("Humanoid") and player.Character:FindFirstChild("HumanoidRootPart")
        applyAnimations()
    end)
end

local function onCharacterAdded(character)
    animationLoaded = false
    repeat task.wait() until character:FindFirstChild("HumanoidRootPart")
    applyAnimations()
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
    task.spawn(function()
        onCharacterAdded(player.Character)
    end)
end

if player.CharacterAdded then
    player.CharacterAdded:Connect(function()
        animationLoaded = false
        task.wait(0.5)
        applyAnimations()
    end)
else
    warn("[Animation Error]: CharacterAdded event not found!")
end

task.spawn(function()
    task.wait(1)
    applyAnimations()
end)

DesyncBox = Tabs.Player:AddRightGroupbox("Player Desync")

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer

desync_setback = Instance.new("Part")
desync_setback.Name = "Desync Setback"
desync_setback.Parent = workspace
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1

desync = {
    enabled = false,
    mode = "Void",
    teleportPosition = Vector3.new(0, 0, 0),
    old_position = nil,
    voidSpamActive = false,
    toggleEnabled = false
}

function resetCamera()
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            workspace.CurrentCamera.CameraSubject = humanoid
        end
    end
end

function toggleDesync(state)
    desync.enabled = state
    if desync.enabled then
        workspace.CurrentCamera.CameraSubject = desync_setback
        Library:Notify("Desync Enabled '" .. desync.mode .. "' Vilant Exploit V2", 2)
    else
        resetCamera()
        Library:Notify("Desync Disabled '" .. desync.mode .. "' Vilant Exploit V2", 2)
    end
end

function setDesyncMode(mode)
    desync.mode = mode
end

DesyncBox:AddToggle('DesyncToggle', {
    Text = 'Desync',
    Default = false,
    Callback = function(state)
        desync.toggleEnabled = state
        if not state then
            toggleDesync(false)
        end
    end,
}):AddKeyPicker('DesyncKeybind', {
    Default = 'V',
    Text = 'Keybind',
    Mode = 'Toggle',
    Callback = function(state)
        if not desync.toggleEnabled or UserInputService:GetFocusedTextBox() then return end
        toggleDesync(not desync.enabled)
    end,
})

DesyncBox:AddDropdown('DesyncMethodDropdown', {
    Values = {"Destroy Cheaters", "Underground", "Void Spam", "Void"},
    Default = "Void",
    Multi = false,
    Text = 'Method',
    Callback = function(selected)
        setDesyncMode(selected)
    end
})

RunService.Heartbeat:Connect(function()
    if desync.enabled and LocalPlayer.Character then
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            desync.old_position = rootPart.CFrame

            if desync.mode == "Destroy Cheaters" then
                desync.teleportPosition = Vector3.new(11223344556677889900, 1, 1)

            elseif desync.mode == "Underground" then
                desync.teleportPosition = rootPart.Position - Vector3.new(0, 12, 0)

            elseif desync.mode == "Void Spam" then
                desync.teleportPosition = math.random(1, 2) == 1 and desync.old_position.Position or Vector3.new(
                    math.random(10000, 50000),
                    math.random(10000, 50000),
                    math.random(10000, 50000)
                )

            elseif desync.mode == "Void" then
                desync.teleportPosition = Vector3.new(
                    rootPart.Position.X + math.random(-444444, 444444),
                    rootPart.Position.Y + math.random(-444444, 444444),
                    rootPart.Position.Z + math.random(-44444, 44444)
                )
            end

            if desync.mode ~= "Rotation" then
                rootPart.CFrame = CFrame.new(desync.teleportPosition)
                workspace.CurrentCamera.CameraSubject = desync_setback

                RunService.RenderStepped:Wait()

                desync_setback.CFrame = desync.old_position * CFrame.new(0, rootPart.Size.Y / 2 + 0.5, 0)
                rootPart.CFrame = desync.old_position
            end
        end
    end
end)

RightGroupBox = Tabs.Player:AddRightGroupbox('Staff Checker')

if _G.staffCheckerEnabled == nil then
    _G.staffCheckerEnabled = false -- Default value
end

RightGroupBox:AddToggle('MyToggle', {
    Text = 'Anti-Staff',
    Default = _G.staffCheckerEnabled,
    Tooltip = 'Enables real-time staff detection',

    Callback = function(Value)
        _G.staffCheckerEnabled = Value
        if Value then
            enableStaffChecker()
        else
            disableStaffChecker()
        end
        print('[Staff Checker] Toggled:', Value)
    end
})

-- Define Services properly
local Services = {
    Players = game:GetService("Players"),
    LocalPlayer = game.Players.LocalPlayer,
}

getgenv().PlayerInfo = Tabs.Player:AddRightGroupbox('Player Misc')

-- View Toggle
PlayerInfo:AddToggle('view', {
    Text = 'Spectate',
    Default = false,
    Callback = function(state)
        if state and getgenv().SelectedTarget then
            local targetPlayer = Services.Players:FindFirstChild(getgenv().SelectedTarget)
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Humanoid") then
                workspace.CurrentCamera.CameraSubject = targetPlayer.Character.Humanoid
            end
        else
            if Services.LocalPlayer.Character and Services.LocalPlayer.Character:FindFirstChild("Humanoid") then
                workspace.CurrentCamera.CameraSubject = Services.LocalPlayer.Character.Humanoid
            end
        end
    end,
})

-- Teleport Button (Safe Teleportation)
PlayerInfo:AddButton('Teleport', function()
    local targetPlayer = Services.Players:FindFirstChild(getgenv().SelectedTarget)
    if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetCFrame = targetPlayer.Character.HumanoidRootPart.CFrame
        -- Safe teleportation (Make sure it's safe before teleporting)
        if targetCFrame then
            Services.LocalPlayer.Character.HumanoidRootPart.CFrame = targetCFrame
        end
    end
end)

getgenv().TargetDropdown = PlayerInfo:AddDropdown('yepyep', {
    SpecialType = 'Player',
    Text = 'Select a Player',
    Tooltip = 'Select a player to perform actions on.',
    Callback = function(value)
        getgenv().SelectedTarget = value
    end,
})

RightGroupBox = Tabs.Player:AddRightGroupbox('Teleports')

MyButton = RightGroupBox:AddButton({
    Text = 'Bank',
    Func = function()
        teleportCFrame = CFrame.new(-442, 39, -284)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'Inside Bank',
    Func = function()
        teleportCFrame = CFrame.new(-443, 23, -284)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})


MyButton = RightGroupBox:AddButton({
    Text = 'Vault',
    Func = function()
        teleportCFrame = CFrame.new(-658, -30, -285)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'Revolver',
    Func = function()
        teleportCFrame = CFrame.new(-634, 21, -132)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'LMG',
    Func = function()
        teleportCFrame = CFrame.new(-626, 23, -295)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'DownHill',
    Func = function()
        teleportCFrame = CFrame.new(-559, 8, -735)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'Military Base',
    Func = function()
        teleportCFrame = CFrame.new(-40, 65, -926)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'Uphill',
    Func = function()
        teleportCFrame = CFrame.new(481, 48, -602)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'Police Station',
    Func = function()
        teleportCFrame = CFrame.new(-264, 21, -93)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

MyButton = RightGroupBox:AddButton({
    Text = 'School',
    Func = function()
        teleportCFrame = CFrame.new(-594, 21, 173)  -- Change this to your desired coordinates
        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(teleportCFrame)
    end,
    DoubleClick = false,
    Tooltip = 'Teleports you to the Bank'
})

local LeftGroupBox = Tabs.Visuals:AddLeftGroupbox('                     ESP')

getgenv().espEnabled = false
getgenv().espColor = Color3.new(0, 0, 0)
getgenv().healthBarEnabled = false
getgenv().cornerESPEnabled = false
getgenv().cornerESPColor = Color3.new(0, 0, 0)

local ESPObjects = {}
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function CreateESP(player)
    if ESPObjects[player] then return end

    local box = Drawing.new("Square")
    box.Thickness = 1
    box.Filled = false
    box.Color = getgenv().espColor
    box.Visible = false

    local healthBar = Drawing.new("Line")
    healthBar.Thickness = 2
    healthBar.Color = Color3.new(0, 1, 0)
    healthBar.Visible = false

    local corners = {}
    for i = 1, 8 do
        local line = Drawing.new("Line")
        line.Thickness = 1
        line.Color = getgenv().cornerESPColor
        line.Visible = false
        table.insert(corners, line)
    end

    ESPObjects[player] = {
        Box = box,
        HealthBar = healthBar,
        Corners = corners
    }
end

local function UpdateESP()
    local cameraCF = Camera.CFrame
    local cameraPos = cameraCF.Position

    for player, objects in pairs(ESPObjects) do
        local character = player.Character
        if character and character:FindFirstChild("HumanoidRootPart") and player ~= LocalPlayer then
            local rootPart = character.HumanoidRootPart
            local humanoid = character:FindFirstChildOfClass("Humanoid")

            if humanoid and humanoid.Health > 0 then
                local rootPosition, onScreen = Camera:WorldToViewportPoint(rootPart.Position)
                local distance = (cameraPos - rootPart.Position).Magnitude

                if onScreen and distance < 500 then
                    local headPosition = Camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, 3, 0))
                    local footPosition = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))

                    local boxHeight = math.abs(headPosition.Y - footPosition.Y)
                    local boxWidth = boxHeight / 1.3

                    if getgenv().espEnabled then
                        objects.Box.Position = Vector2.new(rootPosition.X - boxWidth / 2.2, headPosition.Y)
                        objects.Box.Size = Vector2.new(boxWidth, boxHeight)
                        objects.Box.Color = getgenv().espColor
                        objects.Box.Visible = true
                    else
                        objects.Box.Visible = false
                    end

                    if getgenv().healthBarEnabled then
                        local healthRatio = humanoid.Health / humanoid.MaxHealth
                        local healthBarX = rootPosition.X - (boxWidth / 2) - 2.3
                        local healthBarYOffset = 0

                        if getgenv().cornerESPEnabled then
                            healthBarYOffset = 5
                        end

                        local healthBarYStart = headPosition.Y + (boxHeight * (1 - healthRatio)) + healthBarYOffset
                        local healthBarYEnd = footPosition.Y

                        objects.HealthBar.From = Vector2.new(healthBarX, math.clamp(healthBarYStart, headPosition.Y, footPosition.Y))
                        objects.HealthBar.To = Vector2.new(healthBarX, healthBarYEnd)
                        objects.HealthBar.Color = Color3.new(1 - healthRatio, healthRatio, 0)
                        objects.HealthBar.Visible = true
                    else
                        objects.HealthBar.Visible = false
                    end

                    if getgenv().cornerESPEnabled then
                        local corners = objects.Corners
                        local color = getgenv().cornerESPColor

                        local x = rootPosition.X - boxWidth / 2
                        local y = headPosition.Y
                        local size = Vector2.new(boxWidth, boxHeight)
                        local offset = size.X * 0.25

                        corners[1].From = Vector2.new(x, y)
                        corners[1].To = Vector2.new(x + offset, y)
                        corners[2].From = Vector2.new(x, y)
                        corners[2].To = Vector2.new(x, y + offset)

                        corners[3].From = Vector2.new(x + size.X, y)
                        corners[3].To = Vector2.new(x + size.X - offset, y)
                        corners[4].From = Vector2.new(x + size.X, y)
                        corners[4].To = Vector2.new(x + size.X, y + offset)

                        corners[5].From = Vector2.new(x, y + size.Y)
                        corners[5].To = Vector2.new(x + offset, y + size.Y)
                        corners[6].From = Vector2.new(x, y + size.Y)
                        corners[6].To = Vector2.new(x, y + size.Y - offset)

                        corners[7].From = Vector2.new(x + size.X, y + size.Y)
                        corners[7].To = Vector2.new(x + size.X - offset, y + size.Y)
                        corners[8].From = Vector2.new(x + size.X, y + size.Y)
                        corners[8].To = Vector2.new(x + size.X, y + size.Y - offset)

                        for _, line in ipairs(corners) do
                            line.Color = color
                            line.Visible = true
                        end
                    else
                        for _, line in ipairs(objects.Corners) do
                            line.Visible = false
                        end
                    end
                else
                    objects.Box.Visible = false
                    objects.HealthBar.Visible = false
                    for _, line in ipairs(objects.Corners) do
                        line.Visible = false
                    end
                end
            else
                objects.Box.Visible = false
                objects.HealthBar.Visible = false
                for _, line in ipairs(objects.Corners) do
                    line.Visible = false
                end
            end
        else
            objects.Box.Visible = false
            objects.HealthBar.Visible = false
            for _, line in ipairs(objects.Corners) do
                line.Visible = false
            end
        end
    end
end

local function DestroyESP(player)
    if ESPObjects[player] then
        ESPObjects[player].Box:Remove()
        ESPObjects[player].HealthBar:Remove()
        for _, line in ipairs(ESPObjects[player].Corners) do
            line:Remove()
        end
        ESPObjects[player] = nil
    end
end

Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        task.wait(0.5)
        CreateESP(player)
    end)
end)

Players.PlayerRemoving:Connect(DestroyESP)

for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

RunService.RenderStepped:Connect(UpdateESP)

LeftGroupBox:AddToggle('ESP Toggle', {
    Text = 'Boxes',
    Default = false,
    Tooltip = 'Toggle the ESP boxes on/off',
    Callback = function(Value)
        getgenv().espEnabled = Value
        if not Value then
            for _, objects in pairs(ESPObjects) do
                objects.Box.Visible = false
            end
        end
    end
}):AddColorPicker('ESP Color', {
    Text = 'ESP Box Color',
    Default = Color3.fromRGB(0, 0, 0),
    Callback = function(Value)
        getgenv().espColor = Value
    end
})

LeftGroupBox:AddToggle('Corner ESP Toggle', {
    Text = 'Corner Boxes',
    Default = false,
    Tooltip = 'Toggle the corner ESP boxes on/off',
    Callback = function(Value)
        getgenv().cornerESPEnabled = Value
        if not Value then
            for _, objects in pairs(ESPObjects) do
                for _, line in ipairs(objects.Corners) do
                    line.Visible = false
                end
            end
        end
    end
}):AddColorPicker('Corner ESP Color', {
    Text = 'Corner Box Color',
    Default = Color3.fromRGB(0, 0, 0),
    Callback = function(Value)
        getgenv().cornerESPColor = Value
    end
})

LeftGroupBox:AddToggle('Health Bar Toggle', {
    Text = 'Health Bar',
    Default = false,
    Tooltip = 'Toggle the ESP health bars on/off',
    Callback = function(Value)
        getgenv().healthBarEnabled = Value
        if not Value then
            for _, objects in pairs(ESPObjects) do
                objects.HealthBar.Visible = false
            end
        end
    end
})

local FORCEFIELD_MATERIAL = Enum.Material.ForceField
local DEFAULT_MATERIAL = Enum.Material.Plastic
local DEFAULT_COLOR = Color3.fromRGB(255, 255, 255)
local currentColor = Color3.fromRGB(0, 255, 0)
local forcefieldEnabled = false

local lastUpdateTime = 0
local updateInterval = 0.1

local function customizeCharacter(character, newColor)
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if forcefieldEnabled then
                part.Color = newColor
                part.Material = FORCEFIELD_MATERIAL
            else
                part.Material = DEFAULT_MATERIAL
                part.Color = DEFAULT_COLOR
            end
        end
    end
end

local function onCharacterAdded(character)
    if forcefieldEnabled then
        customizeCharacter(character, currentColor)
    end
end

player.CharacterAdded:Connect(onCharacterAdded)

LeftGroupBox:AddToggle('ForcefieldToggle', {
    Text = 'Forcefield',
    Default = false,
    Tooltip = 'Toggle the forcefield effect on your character.',
    Callback = function(Value)
        forcefieldEnabled = Value
        local character = player.Character
        if character then
            customizeCharacter(character, currentColor)
        end
    end
}):AddColorPicker('ForcefieldColorPicker', {
    Default = currentColor,
    Title = 'Select Forcefield Color',
    Transparency = 0,
    Callback = function(Value)
        currentColor = Value
        local character = player.Character
        if forcefieldEnabled and character then
            customizeCharacter(character, currentColor)
        end
    end
})

local RightGroupBox = Tabs.Visuals:AddRightGroupbox('Audio Player')  

local soundEnabled = false 
local soundVolume = 1
local soundList = {     
    ["No disrespect"] = 90317758270266,     
    ["The city of Memphis"] = 106172723805803,     
    ["Los Gangster  [inst]"] = 107558212312864,
    ["with my chest"] = 85096138905039,
    ["lucid dreams"] = 1837103530,
    ["jc wrld"] = 5410084938,
    ["2023 ah phonk"] = 15689451063,
    ["die with a smile"] = 80511230354401,
    ["sigma boy funk"] = 87459334689630
}

local selectedSound = soundList["with my chest"]

local currentSound = nil

local function getSoundKeys()
    local keys = {}
    for key, _ in pairs(soundList) do
        table.insert(keys, key)
    end
    return keys
end

RightGroupBox:AddToggle('EnableMusic', {     
    Text = 'Enable Music',     
    Default = false,     
    Tooltip = 'Turn the music system on/off',         
    Callback = function(Value)         
        soundEnabled = Value     
        if not soundEnabled and currentSound then
            currentSound:Stop()
            currentSound:Destroy()
            currentSound = nil
            print("Sound stopped as the toggle is off.")
        end
    end 
})  

RightGroupBox:AddDropdown('SoundDropdown', {     
    Values = getSoundKeys(),     
    Default = 1,     
    Multi = false,     
    Text = 'Select Sound',         
    Callback = function(Value)         
        selectedSound = soundList[Value]     
    end 
})  

RightGroupBox:AddSlider('VolumeSlider', {     
    Text = 'Sound Volume',     
    Default = soundVolume,     
    Min = 0,     
    Max = 5,     
    Rounding = 1,     
    Compact = false,     
    Callback = function(Value)         
        soundVolume = Value 
        print('[cb] Volume set to:', Value)
        if currentSound then
            currentSound.Volume = soundVolume
        end
    end 
})

RightGroupBox:AddButton({     
    Text = 'Play Music',     
    Func = function()         
        if soundEnabled then
            print("Sound Enabled: Attempting to play sound")

            if currentSound then
                currentSound:Stop()
                currentSound:Destroy()
            end

            currentSound = Instance.new("Sound")
            currentSound.SoundId = "rbxassetid://" .. selectedSound
            currentSound.Volume = soundVolume
            currentSound.Parent = game:GetService("SoundService") 

            currentSound:Play()

            currentSound.Ended:Connect(function()
                currentSound:Destroy()
                currentSound = nil
            end)
        else
            print("Sound is Disabled")
        end
    end,     
    Tooltip = 'Plays the selected sound' 
})

getgenv().envt = Tabs.Visuals:AddLeftGroupbox("Ambience")
getgenv().Lighting = game:GetService("Lighting")

getgenv().DefaultFogStart = Lighting.FogStart
getgenv().DefaultFogEnd = Lighting.FogEnd
getgenv().DefaultFogColor = Lighting.FogColor
getgenv().DefaultAmbient = Lighting.Ambient
getgenv().DefaultTechnology = Lighting.Technology.Name

getgenv().FogModified = false
getgenv().AmbientModified = false

envt:AddToggle('FogToggle', {
    Text = 'Fog',
    Default = false,
    Callback = function(Value)
        if Value then
            Lighting.FogEnd = getgenv().FogEnd or DefaultFogEnd
            Lighting.FogStart = getgenv().FogStart or DefaultFogStart
            getgenv().FogModified = true  -- Track if fog settings are modified
        else
            Lighting.FogEnd = DefaultFogEnd
            Lighting.FogStart = DefaultFogStart
            Lighting.FogColor = DefaultFogColor
            getgenv().FogModified = false  -- Reset flag
        end
    end
}):AddColorPicker('FogColor', {
    Default = DefaultFogColor,
    Title = 'Fog Color',
    Callback = function(Value)
        Lighting.FogColor = Value
    end
})

envt:AddSlider('FogStart', {
    Text = 'Fog Start',
    Default = DefaultFogStart,
    Min = 0,
    Max = 1000,
    Rounding = 1,
    Callback = function(Value)
        getgenv().FogStart = Value
        Lighting.FogStart = Value
    end
})

envt:AddSlider('FogEnd', {
    Text = 'Fog End',
    Default = DefaultFogEnd,
    Min = 10,
    Max = 10000,
    Rounding = 1,
    Callback = function(Value)
        getgenv().FogEnd = Value
        Lighting.FogEnd = Value
    end
})

envt:AddToggle('AmbientToggle', {
    Text = 'Ambient',
    Default = false,
    Callback = function(Value)
        if Value then
            Lighting.Ambient = getgenv().AmbientColor or DefaultAmbient
            getgenv().AmbientModified = true
        else
            Lighting.Ambient = DefaultAmbient
            getgenv().AmbientModified = false
        end
    end
}):AddColorPicker('AmbientColor', {
    Default = DefaultAmbient,
    Title = 'Ambient Color',
    Callback = function(Value)
        getgenv().AmbientColor = Value
        Lighting.Ambient = Value
    end
})

function restoreDefaultLightingSettings()
    if not getgenv().FogModified then
        Lighting.FogStart = DefaultFogStart
        Lighting.FogEnd = DefaultFogEnd
        Lighting.FogColor = DefaultFogColor
    end
    
    if not getgenv().AmbientModified then
        Lighting.Ambient = DefaultAmbient
    end
end

local RightGroupbox = Tabs.Visuals:AddRightGroupbox('Settings')

RightGroupbox:AddToggle('NoFogToggle', {
    Text = 'No fog',
    Default = false,
    Tooltip = 'This removes any kind of Fog from the game',
    Callback = function(Value)
        local lighting = game:GetService("Lighting")

        if Value then
            if not _G.FogRemovalExecuted then
                _G.OriginalFogSettings = {
                    FogEnd = lighting.FogEnd,
                    FogStart = lighting.FogStart
                }

                lighting.FogEnd = 100000
                lighting.FogStart = 0

                local atmosphere = lighting:FindFirstChildOfClass("Atmosphere")
                if atmosphere then
                    atmosphere:Destroy()
                end

                _G.FogRemovalExecuted = true
            end
        else
            if _G.FogRemovalExecuted then
                lighting.FogEnd = _G.OriginalFogSettings.FogEnd
                lighting.FogStart = _G.OriginalFogSettings.FogStart
                _G.FogRemovalExecuted = false
            end
        end
        print('[cb] NoFogToggle changed to:', Value)
    end
})

RightGroupbox:AddToggle('BrightToggle', {
    Text = 'No shadows',
    Default = false,
    Tooltip = 'Removes shadows and increases brightness',
    Callback = function(Value)
        if not _G.FullBrightExecuted then
            _G.FullBrightEnabled = false

            local Lighting = game:GetService("Lighting")

            _G.NormalLightingSettings = {
                Brightness = Lighting.Brightness,
                ClockTime = Lighting.ClockTime,
                GlobalShadows = Lighting.GlobalShadows
            }

            local FullBrightSettings = {
                Brightness = 1,
                ClockTime = 12,
                GlobalShadows = false
            }

            local function setLightingProperties(properties)
                for property, value in pairs(properties) do
                    Lighting[property] = value
                end
            end

            setLightingProperties(FullBrightSettings)

            local function createPropertyChangeListener(property, newValue)
                Lighting:GetPropertyChangedSignal(property):Connect(function()
                    if Lighting[property] ~= _G.NormalLightingSettings[property] then
                        _G.NormalLightingSettings[property] = Lighting[property]
                        if not _G.FullBrightEnabled then
                            repeat wait() until _G.FullBrightEnabled
                        end
                        Lighting[property] = newValue
                    end
                end)
            end

            for property, newValue in pairs(FullBrightSettings) do
                createPropertyChangeListener(property, newValue)
            end

            spawn(function()
                local LatestValue = true
                while wait() do
                    if _G.FullBrightEnabled ~= LatestValue then
                        if not _G.FullBrightEnabled then
                            setLightingProperties(_G.NormalLightingSettings)
                        else
                            setLightingProperties(FullBrightSettings)
                        end
                        LatestValue = not LatestValue
                    end
                end
            end)
        end

        _G.FullBrightExecuted = true
        _G.FullBrightEnabled = Value
    end
})

local MenuGroup = Tabs['Visuals']:AddRightGroupbox('')

MenuGroup:AddButton('Unload', function() Library:Unload() end)

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 60;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;

    Library:SetWatermark(('Sazurn Hub - Da Hood | v1.0.0 | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ));
end);

print("SazurnHub | Da Hood | Loaded successfully.")
